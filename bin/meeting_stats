#!/usr/bin/env ruby

require 'optparse'
require 'date'
require 'sqlite3'
require 'fileutils'
require 'gruff'
require 'readline'

require_relative '../lib/oss_stats/log'
require_relative '../lib/oss_stats/config/meeting_stats'

# Initialize database with new schema
def initialize_db(db_file)
  db = SQLite3::Database.new(db_file)

  # Create teams table
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS teams (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT UNIQUE NOT NULL
    );
  SQL

  # Create meeting_stats table with foreign key to teams
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS meeting_stats (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      meeting_date TEXT,
      team_id INTEGER,
      present TEXT,
      current_work TEXT,
      build_status TEXT,
      fix_points TEXT,
      extra TEXT,
      FOREIGN KEY(team_id) REFERENCES teams(id),
      UNIQUE(meeting_date, team_id)
    );
  SQL

  db
end

# Check if database needs migration from old schema
def needs_migration?(db)
  # Check if the old schema exists (team column as TEXT)
  columns = db.execute(
    'PRAGMA table_info(meeting_stats)',
  ).map { |col| [col[1], col[2]] }.to_h

  # If meeting_stats doesn't exist yet, no migration needed
  return false if columns.empty?

  # If team column exists and is TEXT, needs migration
  columns['team'] == 'TEXT'
end

# Migrate database from old schema to new schema
def migrate_db(db)
  log.info('Detected old database schema, migrating...')

  db.execute('BEGIN TRANSACTION')

  begin
    # Create teams table
    db.execute <<-SQL
      CREATE TABLE IF NOT EXISTS teams (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL
      );
    SQL

    # Extract unique team names and insert into teams table
    old_teams = db.execute(
      'SELECT DISTINCT team FROM meeting_stats ORDER BY team',
    ).flatten

    old_teams.each do |team_name|
      db.execute(
        'INSERT OR IGNORE INTO teams (name) VALUES (?)',
        [team_name],
      )
    end

    # Create new meeting_stats table with proper schema
    db.execute <<-SQL
      CREATE TABLE meeting_stats_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        meeting_date TEXT,
        team_id INTEGER,
        present TEXT,
        current_work TEXT,
        build_status TEXT,
        fix_points TEXT,
        extra TEXT,
        FOREIGN KEY(team_id) REFERENCES teams(id),
        UNIQUE(meeting_date, team_id)
      );
    SQL

    # Migrate data from old table to new table
    db.execute <<-SQL
      INSERT INTO meeting_stats_new
        (meeting_date, team_id, present, current_work,
         build_status, fix_points, extra)
      SELECT
        ms.meeting_date,
        t.id,
        ms.present,
        ms.current_work,
        ms.build_status,
        ms.fix_points,
        ms.extra
      FROM meeting_stats ms
      JOIN teams t ON ms.team = t.name;
    SQL

    # Drop old table and rename new one
    db.execute('DROP TABLE meeting_stats')
    db.execute(
      'ALTER TABLE meeting_stats_new RENAME TO meeting_stats',
    )

    db.execute('COMMIT')
    log.info('Migration completed successfully!')
  rescue StandardError => e
    db.execute('ROLLBACK')
    log.error("Migration failed: #{e.message}")
    raise
  end
end

# Rename a team in the database
def rename_team(db_file, config)
  db = SQLite3::Database.new(db_file)
  teams = db.execute('SELECT name FROM teams ORDER BY name').flatten

  if teams.empty?
    log.info('No teams found in database.')
    db.close
    return
  end

  log.info('Current teams in database:')
  teams.each { |team| log.info("  - #{team}") }
  log.info('')

  setup_readline_completion(teams)

  old_name = Readline.readline('Team to rename (TAB to complete): ', true)
  return if old_name.nil? || old_name.strip.empty?

  old_name = old_name.strip

  # Find exact match (case-insensitive)
  matched_team = teams.find { |t| t.downcase == old_name.downcase }

  unless matched_team
    log.error("Team '#{old_name}' not found in database.")
    db.close
    return
  end

  print "New name for '#{matched_team}': "
  new_name = gets.strip

  if new_name.empty?
    log.error('New team name cannot be empty.')
    db.close
    return
  end

  if teams.any? { |t| t.downcase == new_name.downcase }
    log.error("Team '#{new_name}' already exists.")
    db.close
    return
  end

  if config.dryrun
    log.info("DRYRUN: Would rename '#{matched_team}' to '#{new_name}'")
  else
    db.execute(
      'UPDATE teams SET name = ? WHERE name = ?',
      [new_name, matched_team],
    )
    log.info("Renamed team '#{matched_team}' to '#{new_name}'")
  end

  db.close
end

# Get last Thursday from a given date (or today)
def get_last_thursday(target_date = Date.today)
  target_date -= 1 while target_date.wday != 4 # 4 = Thursday
  target_date
end

# Prompt user for a Yes/No response
def prompt_yes_no(question)
  loop do
    print "#{question} (y/N): "
    response = gets.strip.downcase
    return response == 'y' if ['y', 'n', ''].include?(response)

    log.info("Please enter 'y' or 'n'.")
  end
end

# Setup readline for case-insensitive completion with given options
def setup_readline_completion(options)
  comp = proc do |s|
    options.select { |opt| opt.downcase.start_with?(s.downcase) }
  end

  Readline.completion_append_character = nil
  Readline.completion_proc = comp

  if Readline.respond_to?(:completion_case_fold=)
    Readline.completion_case_fold = true
  end

  # Remove space from word break characters so multi-word
  # options like "Chef Client" are treated as one word
  return unless Readline.respond_to?(:completer_word_break_characters=)

  original_word_break = Readline.completer_word_break_characters
  Readline.completer_word_break_characters =
    original_word_break.delete(' ')
end

def prompt_team_or_q(teams)
  all_options = teams + %w{other finish f abort}
  setup_readline_completion(all_options)

  loop do
    log.info(
      'Choose a team that was present (type to search, TAB to complete):',
    )
    teams.each do |team|
      log.info("  - #{team}")
    end
    log.info("\n  - other (for a team not in the list)")
    log.info('  - abort (to quit without saving)')
    log.info('  - [f]inish (to save)')
    log.info('')
    response = Readline.readline('Team?> ', true)

    # Handle Ctrl-C or Ctrl-D
    return false if response.nil?

    response = response.strip
    return false if %w{f finish}.include?(response.downcase)

    exit(0) if response.downcase == 'abort'

    # Check if it's an exact match for a known team (case-insensitive)
    matched_team = teams.find { |t| t.downcase == response.downcase }
    return matched_team if matched_team

    if response.downcase == 'other'
      print 'Team name: '
      new_team = gets.strip
      return new_team unless new_team.empty?

      log.error('Team name cannot be empty')
      next
    end

    log.error('Please enter a valid options')
  end
end

# Collect team data from user
def collect_team_data(meeting_date)
  teams = OssStats::Config::MeetingStats.teams
  team_data = {}

  log.info("Please fill in data about the #{meeting_date} meeting\n")
  loop do
    team = prompt_team_or_q(teams)
    unless team
      missing_teams = teams - team_data.keys
      confirm = true
      unless missing_teams.empty?
        log.info(
          'The following teams will be recorded as not present: ' +
             missing_teams.join(', '),
        )
        confirm = prompt_yes_no('Is that correct?')
      end
      next unless confirm

      missing_teams.each do |mt|
        team_data[mt] = {
          'present' => false,
          'current_work' => false,
          'build_status' => '',
          'fix_pointers' => '-',
          'extra' => '-',
        }
      end
      break

    end

    if team_data[team]
      unless prompt_yes_no("WARNING: #{team} data already input - overwrite?")
        next
      end

      log.info("OK, overwriting data for #{team} on #{meeting_date}")

    end

    log.info("\nTeam: #{team}")
    log.info('  -> Marking team as present')
    team_data[team] = {}
    team_data[team]['present'] = true
    team_data[team]['current_work'] = prompt_yes_no(
      '  -> Did they discuss current work?',
    )
    log.info('  -> Enter build status (leave empty if they didn\'t say)')
    print "     (e.g. empty, 'green', 'red', or 'main:green, 18:red'): "
    build_status = gets.strip
    team_data[team]['build_status'] = build_status
    fix_pointers = if build_status.include?('red')
                     if prompt_yes_no(
                       '  ----> Did they point to work to fix the build?',
                     )
                       'Y'
                     else
                       'N'
                     end
                   else
                     '-'
                   end
    team_data[team]['fix_pointers'] = fix_pointers
    extra = []
    merged_prs = prompt_yes_no('  -> Did they list merged PRs that week?')
    extra << 'listed merged PRs' if merged_prs
    print '  -> Any extra notes? (leave empty if none): '
    extra_notes = gets.strip
    extra << extra_notes unless extra_notes.empty?
    team_data[team]['extra'] = if extra.empty?
                                 '-'
                               else
                                 extra.join(', ')
                               end
    log.info
  end
  team_data.map do |team, info|
    [
      team,
      info['present'] ? 'Y' : 'N',
      info['current_work'] ? 'Y' : 'N',
      info['build_status'],
      info['fix_points'],
      info['extra'],
    ]
  end
end

# Get or create team ID
def get_or_create_team_id(db, team_name)
  result = db.execute(
    'SELECT id FROM teams WHERE name = ?',
    [team_name],
  )
  return result[0][0] unless result.empty?

  db.execute('INSERT INTO teams (name) VALUES (?)', [team_name])
  db.last_insert_row_id
end

# Insert meeting data into the database
def record_meeting_data(meeting_date, team_data, config)
  if config.dryrun
    log.info('DRYRUN: Would record the following rows:')
    team_data.each do |row|
      log.info(row.join(', '))
    end
    return
  end

  db = SQLite3::Database.new(config.db_file)
  team_data.each do |row|
    team_name = row.first
    team_id = get_or_create_team_id(db, team_name)

    db.execute(
      'INSERT INTO meeting_stats ' +
      '(meeting_date, team_id, present, current_work, ' +
      'build_status, fix_points, extra) ' +
      'VALUES (?, ?, ?, ?, ?, ?, ?) ' +
      'ON CONFLICT(meeting_date, team_id) DO UPDATE ' +
      'SET present=excluded.present, ' +
      'current_work=excluded.current_work, ' +
      'build_status=excluded.build_status, ' +
      'fix_points=excluded.fix_points, ' +
      'extra=excluded.extra',
      [meeting_date.to_s, team_id] + row[1..-1],
    )
  end
  db.close
  log.info("Data recorded for #{meeting_date}.")
end

# Format Yes/No to display emojis
#
# if `force`, that means nil is the same as no.
def format_yes_no(value, force = false)
  return ':x:' unless value

  case value.strip.upcase
  when 'N'
    force ? ':x:' : ':red_circle:'
  when 'Y'
    ':white_check_mark:'
  else
    value
  end
end

# Format build status to display emojis correctly
def format_build_status(status)
  return ':x:' if status.nil? || status.strip.empty?

  status = "main:#{status}" if %w{red green}.include?(status)
  status.gsub('red', ' :red_circle:').gsub('green', ' :white_check_mark:')
end

# Generate Markdown table
def generate_md_page(db_file)
  db = SQLite3::Database.new(db_file)
  meeting_dates = db.execute(
    'SELECT DISTINCT meeting_date FROM meeting_stats ' +
    'ORDER BY meeting_date DESC',
  ).flatten
  md = [OssStats::Config::MeetingStats.header]

  meeting_dates.each do |meeting_date|
    team_data = db.execute(
      'SELECT t.name, ms.present, ms.current_work, ' +
      'ms.build_status, ms.fix_points, ms.extra ' +
      'FROM meeting_stats ms ' +
      'JOIN teams t ON ms.team_id = t.id ' +
      'WHERE ms.meeting_date = ? ' +
      'ORDER BY t.name',
      [meeting_date],
    )
    md << "## #{meeting_date}"
    md << ''
    md << '| Team | Present | Current work | Build Status |' +
          ' If builds broken, points to work to fix it | Extra |'
    md << '| --- | ---- | --- | --- | --- | --- |'
    team_data.each do |row|
      row = row.dup # This makes the row mutable
      row[1] = format_yes_no(row[1], true)  # Present
      row[2] = format_yes_no(row[2], true)  # Current work
      row[3] = format_build_status(row[3]) # Build Status
      row[4] = if row[3].include?('❌')
                 format_yes_no(row[4]) # Fix points
               else
                 '➖'
               end
      md << '| ' + row.join(' | ') + ' |'
    end
    md << ''
  end
  db.close
  md.join("\n")
end

def summary(db_file)
  db = SQLite3::Database.new(db_file)
  data = db.execute(
    'SELECT ms.meeting_date, t.name, ms.present, ms.build_status' +
    ' FROM meeting_stats ms' +
    ' JOIN teams t ON ms.team_id = t.id' +
    ' ORDER BY ms.meeting_date ASC',
  )
  db.close

  # TODO: de-dupe this with generate_plots
  dates = data.map(&:first).uniq.reverse
  dates[0..2].each do |date|
    total_teams = data.count { |row| row.first == date }
    present_teams = data.count { |row| row.first == date && row[2] == 'Y' }
    present_pct = ((present_teams / total_teams) * 100).round(2)
    reporting_builds = data.count do |row|
      row.first == date && row[3] != 'N' && !row[3].strip.empty?
    end
    reporting_builds_pct =
      ((reporting_builds.to_f / total_teams) * 100).round(2)

    puts "* #{date}:"
    puts "    * Teams reported: #{present_teams} out of #{total_teams} (" +
         "#{present_pct}%)"
    puts "    * Teams reporting build status: #{reporting_builds} out of " +
         "#{total_teams} (#{reporting_builds_pct}%)\n"
  end
end

def generate_plots(db_file, img_dir)
  db = SQLite3::Database.new(db_file)
  data = db.execute(
    'SELECT ms.meeting_date, t.name, ms.present, ms.build_status' +
    ' FROM meeting_stats ms' +
    ' JOIN teams t ON ms.team_id = t.id' +
    ' ORDER BY ms.meeting_date ASC',
  )
  db.close

  dates = data.map(&:first).uniq
  attendance_percentages = []
  build_status_percentages = []

  dates.each do |date|
    total_teams = data.count { |row| row.first == date }
    present_teams = data.count { |row| row.first == date && row[2] == 'Y' }
    reporting_builds = data.count do |row|
      row.first == date && row[3] != 'N' && !row[3].strip.empty?
    end

    attendance_percentages <<
      (total_teams == 0 ? 0 : (present_teams.to_f / total_teams) * 100)
    build_status_percentages <<
      (total_teams == 0 ? 0 : (reporting_builds.to_f / total_teams) * 100)
  end

  sizes = {
    'full' => [800, 500],
    'small' => [400, 250],
  }

  sizes.each do |name, size|
    g = Gruff::Line.new(size.first, size[1])
    g.maximum_value = 100
    g.minimum_value = 0
    g.title = 'Percentage of Teams Present Over Time'
    g.data('% Teams Present', attendance_percentages)
    g.labels = dates.each_with_index.to_h
    g.write(::File.join(img_dir, "attendance-#{name}.png"))

    g2 = Gruff::Line.new(size.first, size[1])
    g2.maximum_value = 100
    g2.minimum_value = 0
    g2.title = 'Percentage of Teams Reporting Build Status Over Time'
    g2.data('% Reporting Build Status', build_status_percentages)
    g2.labels = dates.each_with_index.to_h
    g2.write(::File.join(img_dir, "build_status-#{name}.png"))
  end
end

# Parse command-line arguments
options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: meeting_stats.rb [options]'

  opts.on(
    '-c FILE',
    '--config FILE',
    'Config file to load. [default: will look for `meeting_stats_config.rb` ' +
    'in `./`, `~/.config/oss_stats`, and `/etc`]',
  ) do |c|
    options[:config] = c
  end

  opts.on(
    '--date DATE',
    'Date of the meeting in YYYY-MM-DD format',
  ) do |v|
    options[:date] =
      begin
        Date.parse(v)
      rescue StandardError
        nil
      end
  end

  opts.on(
    '-f FILE',
    '--db-file FILE',
    'SQLLite file. Will be created if it does not exist. ' +
    '[default: ./data/meeting_data.sqlite3]',
  ) do |f|
    options[:db_file] = f
  end

  opts.on(
    '-i DIR',
    '--image-dir DIR',
    'Directory to drop plot images in. [default: ./images]',
  ) do |dir|
    options[:image_dir] = dir
  end

  opts.on(
    '-l LEVEL',
    '--log-level LEVEL',
    'Set logging level to LEVEL. [default: info]',
  ) do |level|
    options[:log_level] = level.to_sym
  end

  opts.on(
    '-m MODE',
    '--mode MODE',
    %w{record generate generate_plot summary rename_team},
    'Mode to operate in. record: Input new meeting info, generate: ' +
    'generate both plot and markdown files, generate_plot: generate ' +
    'new plots, summary: generate summary of last 3 meetings, ' +
    'rename_team: rename a team in the database [default: record]',
  ) do |v|
    options[:mode] = v
  end

  opts.on('-n', '--dryrun', 'Do not actually make changes') do |_v|
    options[:dryrun] = true
  end

  opts.on(
    '-o FILE',
    '--output FILE',
    'Write output to FILE [default: ./meeting_stats.md]',
  ) do |f|
    options[:output] = f
  end
end.parse!
log.level = options[:log_level] if options[:log_level]
config = OssStats::Config::MeetingStats

if options[:config]
  expanded_config = File.expand_path(options[:config])
else
  f = config.config_file
  expanded_config = File.expand_path(f) if f
end

if expanded_config && File.exist?(expanded_config)
  log.info("Loading config from #{expanded_config}")
  config.from_file(expanded_config)
end
config.merge!(options)
log.level = config.log_level

log.debug("Full config: #{config.to_hash}")

db = initialize_db(config.db_file)

# Check and migrate database if needed
migrate_db(db) if needs_migration?(db)

db.close

meeting_date = config.date || get_last_thursday

case config.mode
when 'record'
  team_data = collect_team_data(meeting_date)
  record_meeting_data(meeting_date, team_data, config)
when 'generate'
  if config.dryrun
    log.info('DRYRUN: Would update plots')
    log.info("DRYRUN: Would update #{config.output} with:")
    log.info(generate_md_page(config.db_file))
  else
    log.info('Updating plots...')
    generate_plots(config.db_file, config.image_dir)
    log.info("Generating #{config.output}")
    File.write(config.output, generate_md_page(config.db_file))
  end
when 'generate_plot'
  if config.dryrun
    log.info('DRYRUN: Would update plots')
  else
    generate_plots(config.db_file, config.image_dir)
    log.info('Plots generated: attendance.png and build_status.png')
  end
when 'summary'
  summary(config.db_file)
when 'rename_team'
  rename_team(config.db_file, config)
else
  log.info('Invalid mode. Use --mode record, generate, generate_plot, ' +
           'summary, or rename_team.')
end
